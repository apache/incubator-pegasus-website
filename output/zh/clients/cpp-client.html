<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pegasus | Cpp Client</title>
    <link rel="stylesheet" href="/zh/assets/css/app.css">
    <link rel="shortcut icon" href="/zh/assets/images/favicon.ico">
    <link rel="stylesheet" href="/zh/assets/css/utilities.min.css">
    <link rel="stylesheet" href="/zh/assets/css/docsearch.v3.css">
    <script src="/assets/js/jquery.min.js"></script>
    <script src="/assets/js/all.min.js"></script>
    <script src="/assets/js/docsearch.v3.js"></script>
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Cpp Client | Pegasus</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Cpp Client" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="获取Cpp客户端 首先需要编译Pegasus，编译完成后运行以下命令可以打包生产Cpp客户端库： ./run.sh pack_client 运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。" />
<meta property="og:description" content="获取Cpp客户端 首先需要编译Pegasus，编译完成后运行以下命令可以打包生产Cpp客户端库： ./run.sh pack_client 运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。" />
<meta property="og:site_name" content="Pegasus" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-11-16T14:12:11+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Cpp Client" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-11-16T14:12:11+00:00","datePublished":"2025-11-16T14:12:11+00:00","description":"获取Cpp客户端 首先需要编译Pegasus，编译完成后运行以下命令可以打包生产Cpp客户端库： ./run.sh pack_client 运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。","headline":"Cpp Client","mainEntityOfPage":{"@type":"WebPage","@id":"/clients/cpp-client"},"url":"/clients/cpp-client"}</script>
<!-- End Jekyll SEO tag -->

</head>


<body>
    <div class="dashboard is-full-height">
        <!-- left panel -->
        <div class="dashboard-panel is-medium is-hidden-mobile pl-0">
            <div class="dashboard-panel-header has-text-centered">
                <a href="/zh/">
                    <img src="/assets/images/pegasus-logo-inv.png" style="width: 80%;">
                </a>
                
            </div>
            <div class="dashboard-panel-main is-scrollable pl-6">
                

<aside class="menu">
    
    <p class="menu-label">Pegasus 产品文档</p>
    <ul class="menu-list">
        
        <li>
            <a href="/zh/docs/downloads"
                class="">
                下载
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">编译构建</p>
    <ul class="menu-list">
        
        <li>
            <a href="/zh/docs/build/compile-by-docker"
                class="">
                使用 Docker 完成编译（推荐）
            </a>
        </li>
        
        <li>
            <a href="/zh/docs/build/compile-from-source"
                class="">
                从源码编译
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">客户端库</p>
    <ul class="menu-list">
        
        <li>
            <a href="/zh/clients/java-client"
                class="">
                Java 客户端
            </a>
        </li>
        
        <li>
            <a href="/zh/clients/cpp-client"
                class="is-active">
                C++ 客户端
            </a>
        </li>
        
        <li>
            <a href="/zh/clients/go-client"
                class="">
                Golang 客户端
            </a>
        </li>
        
        <li>
            <a href="/zh/clients/python-client"
                class="">
                Python 客户端
            </a>
        </li>
        
        <li>
            <a href="/zh/clients/node-client"
                class="">
                NodeJS 客户端
            </a>
        </li>
        
        <li>
            <a href="/zh/clients/scala-client"
                class="">
                Scala 客户端
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">生态工具</p>
    <ul class="menu-list">
        
        <li>
            <a href="/zh/docs/tools/shell"
                class="">
                Pegasus Shell 工具
            </a>
        </li>
        
        <li>
            <a href="https://github.com/pegasus-kv/admin-cli"
                class="">
                集群管理命令行
            </a>
        </li>
        
        <li>
            <a href="https://github.com/pegasus-kv/pegic"
                class="">
                数据访问命令行
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">用户接口</p>
    <ul class="menu-list">
        
        <li>
            <a href="/zh/api/ttl"
                class="">
                TTL
            </a>
        </li>
        
        <li>
            <a href="/zh/api/single-atomic"
                class="">
                单行原子操作
            </a>
        </li>
        
        <li>
            <a href="/zh/api/redis"
                class="">
                Redis 适配
            </a>
        </li>
        
        <li>
            <a href="/zh/api/geo"
                class="">
                GEO 支持
            </a>
        </li>
        
        <li>
            <a href="/zh/api/http"
                class="">
                HTTP 接口
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">高效运维</p>
    <ul class="menu-list">
        
        <li>
            <a href="/zh/administration/deployment"
                class="">
                集群部署
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/config"
                class="">
                配置说明
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/rebalance"
                class="">
                负载均衡
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/monitoring"
                class="">
                可视化监控
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/rolling-update"
                class="">
                集群重启和升级
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/scale-in-out"
                class="">
                集群扩容缩容
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/resource-management"
                class="">
                资源管理
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/cold-backup"
                class="">
                冷备份
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/meta-recovery"
                class="">
                元数据恢复
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/replica-recovery"
                class="">
                Replica 数据恢复
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/zk-migration"
                class="">
                Zookeeper 迁移
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/table-migration"
                class="">
                Table 迁移
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/table-soft-delete"
                class="">
                Table 软删除
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/table-env"
                class="">
                Table 环境变量
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/remote-commands"
                class="">
                远程命令
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/partition-split"
                class="">
                Partition-Split
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/duplication"
                class="">
                跨机房同步
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/compression"
                class="">
                数据压缩
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/throttling"
                class="">
                流量控制
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/experiences"
                class="">
                运维经验
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/manual-compact"
                class="">
                Manual Compact 功能
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/usage-scenario"
                class="">
                Usage Scenario 功能
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/bad-disk"
                class="">
                坏盘检修
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/whitelist"
                class="">
                Replica Server 白名单
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/backup-request"
                class="">
                Backup Request
            </a>
        </li>
        
        <li>
            <a href="/zh/administration/hotspot-detection"
                class="">
                热点检测
            </a>
        </li>
        
    </ul>
    
</aside>
            </div>
        </div>

        <!-- main section -->
        <div class="dashboard-main is-scrollable">
            <nav class="navbar is-hidden-desktop">
    <div class="navbar-brand">
        <a href="/zh/" class="navbar-item">
            <!-- Pegasus Icon -->
            <img src="/assets/images/pegasus-square.png">
        </a>
        <div class="navbar-item">
            

<!--A simple language switch button that only supports zh and en.-->
<!--IF its language is zh, then switches to en.-->

<!--If you don't want a url to be relativized, you can add a space explicitly into the href to 
    prevents a url from being relativized by polyglot.-->
<a class="button is-light is-outlined is-inverted" href=" /clients/cpp-client"><strong>En</strong></a>

        </div>
        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navMenu">
            <!-- Appears in mobile mode only -->
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
    </div>
    <div class="navbar-menu" id="navMenu">
        <div class="navbar-end">
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        Pegasus 产品文档
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/zh/docs/downloads"
                        class="navbar-item ">
                        下载
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        编译构建
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/zh/docs/build/compile-by-docker"
                        class="navbar-item ">
                        使用 Docker 完成编译（推荐）
                    </a>
                    
                    <a href="/zh/docs/build/compile-from-source"
                        class="navbar-item ">
                        从源码编译
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        客户端库
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/zh/clients/java-client"
                        class="navbar-item ">
                        Java 客户端
                    </a>
                    
                    <a href="/zh/clients/cpp-client"
                        class="navbar-item is-active">
                        C++ 客户端
                    </a>
                    
                    <a href="/zh/clients/go-client"
                        class="navbar-item ">
                        Golang 客户端
                    </a>
                    
                    <a href="/zh/clients/python-client"
                        class="navbar-item ">
                        Python 客户端
                    </a>
                    
                    <a href="/zh/clients/node-client"
                        class="navbar-item ">
                        NodeJS 客户端
                    </a>
                    
                    <a href="/zh/clients/scala-client"
                        class="navbar-item ">
                        Scala 客户端
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        生态工具
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/zh/docs/tools/shell"
                        class="navbar-item ">
                        Pegasus Shell 工具
                    </a>
                    
                    <a href="https://github.com/pegasus-kv/admin-cli"
                        class="navbar-item ">
                        集群管理命令行
                    </a>
                    
                    <a href="https://github.com/pegasus-kv/pegic"
                        class="navbar-item ">
                        数据访问命令行
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        用户接口
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/zh/api/ttl"
                        class="navbar-item ">
                        TTL
                    </a>
                    
                    <a href="/zh/api/single-atomic"
                        class="navbar-item ">
                        单行原子操作
                    </a>
                    
                    <a href="/zh/api/redis"
                        class="navbar-item ">
                        Redis 适配
                    </a>
                    
                    <a href="/zh/api/geo"
                        class="navbar-item ">
                        GEO 支持
                    </a>
                    
                    <a href="/zh/api/http"
                        class="navbar-item ">
                        HTTP 接口
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        高效运维
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/zh/administration/deployment"
                        class="navbar-item ">
                        集群部署
                    </a>
                    
                    <a href="/zh/administration/config"
                        class="navbar-item ">
                        配置说明
                    </a>
                    
                    <a href="/zh/administration/rebalance"
                        class="navbar-item ">
                        负载均衡
                    </a>
                    
                    <a href="/zh/administration/monitoring"
                        class="navbar-item ">
                        可视化监控
                    </a>
                    
                    <a href="/zh/administration/rolling-update"
                        class="navbar-item ">
                        集群重启和升级
                    </a>
                    
                    <a href="/zh/administration/scale-in-out"
                        class="navbar-item ">
                        集群扩容缩容
                    </a>
                    
                    <a href="/zh/administration/resource-management"
                        class="navbar-item ">
                        资源管理
                    </a>
                    
                    <a href="/zh/administration/cold-backup"
                        class="navbar-item ">
                        冷备份
                    </a>
                    
                    <a href="/zh/administration/meta-recovery"
                        class="navbar-item ">
                        元数据恢复
                    </a>
                    
                    <a href="/zh/administration/replica-recovery"
                        class="navbar-item ">
                        Replica 数据恢复
                    </a>
                    
                    <a href="/zh/administration/zk-migration"
                        class="navbar-item ">
                        Zookeeper 迁移
                    </a>
                    
                    <a href="/zh/administration/table-migration"
                        class="navbar-item ">
                        Table 迁移
                    </a>
                    
                    <a href="/zh/administration/table-soft-delete"
                        class="navbar-item ">
                        Table 软删除
                    </a>
                    
                    <a href="/zh/administration/table-env"
                        class="navbar-item ">
                        Table 环境变量
                    </a>
                    
                    <a href="/zh/administration/remote-commands"
                        class="navbar-item ">
                        远程命令
                    </a>
                    
                    <a href="/zh/administration/partition-split"
                        class="navbar-item ">
                        Partition-Split
                    </a>
                    
                    <a href="/zh/administration/duplication"
                        class="navbar-item ">
                        跨机房同步
                    </a>
                    
                    <a href="/zh/administration/compression"
                        class="navbar-item ">
                        数据压缩
                    </a>
                    
                    <a href="/zh/administration/throttling"
                        class="navbar-item ">
                        流量控制
                    </a>
                    
                    <a href="/zh/administration/experiences"
                        class="navbar-item ">
                        运维经验
                    </a>
                    
                    <a href="/zh/administration/manual-compact"
                        class="navbar-item ">
                        Manual Compact 功能
                    </a>
                    
                    <a href="/zh/administration/usage-scenario"
                        class="navbar-item ">
                        Usage Scenario 功能
                    </a>
                    
                    <a href="/zh/administration/bad-disk"
                        class="navbar-item ">
                        坏盘检修
                    </a>
                    
                    <a href="/zh/administration/whitelist"
                        class="navbar-item ">
                        Replica Server 白名单
                    </a>
                    
                    <a href="/zh/administration/backup-request"
                        class="navbar-item ">
                        Backup Request
                    </a>
                    
                    <a href="/zh/administration/hotspot-detection"
                        class="navbar-item ">
                        热点检测
                    </a>
                    
                </div>
            </div>
            
        </div>
    </div>
</nav>

<nav class="navbar is-hidden-mobile">
    <div class="navbar-start w-full">
        <div class="navbar-item pl-0 w-full">
            <!--TODO(wutao): Given the limitation of docsearch that couldn't handle multiple input,
                I make searchbox only shown in desktop. Fix this issue when docsearch.js v3 released.
                Related issue: https://github.com/algolia/docsearch/issues/230-->
            <div id="docsearch"></div>
        </div>
    </div>
    <div class="navbar-end">
        <div class="navbar-item">
            

<!--A simple language switch button that only supports zh and en.-->
<!--IF its language is zh, then switches to en.-->

<!--If you don't want a url to be relativized, you can add a space explicitly into the href to 
    prevents a url from being relativized by polyglot.-->
<a class="button is-light is-outlined is-inverted" href=" /clients/cpp-client"><strong>En</strong></a>

        </div>
    </div>
</nav>

            <section class="hero is-info lg:mr-3">
                <div class="hero-body">
                    
                    <p class="title is-size-2 is-centered">C++ 客户端</p>
                </div>
            </section>
            <section class="section" style="padding-top: 2rem;">
                <div class="content">
                    <h1 id="获取cpp客户端">获取Cpp客户端</h1>
<p>首先需要<a href="/zh/overview/compilation">编译Pegasus</a>，编译完成后运行以下命令可以打包生产Cpp客户端库：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./run.sh pack_client
</code></pre></div></div>
<p>运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。</p>

<h1 id="配置文件">配置文件</h1>
<p>Cpp客户端由于使用了rdsn框架，所以配置文件较为复杂，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[apps..default]
run = true
count = 1
;network.client.RPC_CHANNEL_TCP = dsn::tools::sim_network_provider, 65536
;network.client.RPC_CHANNEL_UDP = dsn::tools::sim_network_provider, 65536
;network.server.0.RPC_CHANNEL_TCP = dsn::tools::sim_network_provider, 65536

[apps.mimic]
type = dsn.app.mimic
arguments =
pools = THREAD_POOL_DEFAULT
run = true
count = 1

[core]
;tool = simulator
;tool = fastrun
tool = nativerun
;toollets = tracer
;toollets = tracer, profiler, fault_injector
pause_on_start = false
cli_local = false
cli_remote = false

start_nfs = false

logging_start_level = LOG_LEVEL_DEBUG
logging_factory_name = dsn::tools::simple_logger
logging_flush_on_exit = true

enable_default_app_mimic = true

data_dir = ./data

[tools.simple_logger]
short_header = true
fast_flush = true
max_number_of_log_files_on_disk = 10
stderr_start_level = LOG_LEVEL_ERROR

[tools.hpc_logger]
per_thread_buffer_bytes = 8192
max_number_of_log_files_on_disk = 10

[tools.simulator]
random_seed = 0

[network]
; how many network threads for network library(used by asio)
io_service_worker_count = 4

; specification for each thread pool
[threadpool..default]
worker_count = 4

[threadpool.THREAD_POOL_DEFAULT]
name = default
partitioned = false
max_input_queue_length = 1024
worker_priority = THREAD_xPRIORITY_NORMAL
worker_count = 4

[task..default]
is_trace = false
is_profile = false
allow_inline = false
fast_execution_in_network_thread = false
rpc_call_header_format = NET_HDR_DSN
rpc_call_channel = RPC_CHANNEL_TCP
rpc_timeout_milliseconds = 5000

[pegasus.clusters]
onebox = @LOCAL_IP@:34601,@LOCAL_IP@:34602,@LOCAL_IP@:34603
another_cluster = @SOME_IP@:34601,@SOME_IP@:34601,@SOME_IP@:34601
</code></pre></div></div>
<p>配置文件的具体解释，请移步<a href="/zh/administration/config">配置说明</a>。</p>

<h1 id="接口定义">接口定义</h1>
<h2 id="创建client实例">创建Client实例</h2>
<p>客户端工厂类</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">pegasus</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">pegasus_client_factory</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">///</span>
    <span class="c1">/// \brief initialize</span>
    <span class="c1">/// initialize pegasus client lib. must call this function before anything else.</span>
    <span class="c1">/// \param config_file</span>
    <span class="c1">/// the configuration file of client lib</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// true indicate the initailize is success.</span>
    <span class="c1">///</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">initialize</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">config_file</span><span class="p">);</span>

    <span class="c1">///</span>
    <span class="c1">/// \brief get_client</span>
    <span class="c1">/// get an instance for a given cluster and a given app name.</span>
    <span class="c1">/// \param cluster_name</span>
    <span class="c1">/// the pegasus cluster name.</span>
    <span class="c1">/// a cluster can have multiple apps.</span>
    <span class="c1">/// \param app_name</span>
    <span class="c1">/// an app is a logical isolated k-v store.</span>
    <span class="c1">/// a cluster can have multiple apps.</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// the client instance. DO NOT delete this client even after usage.</span>
    <span class="k">static</span> <span class="n">pegasus_client</span> <span class="o">*</span><span class="n">get_client</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cluster_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">app_name</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">//end namespace</span>
</code></pre></div></div>
<p>客户端的初始化，实际上是对rdsn框架初始化</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pegasus</span><span class="o">::</span><span class="n">pegasus_client_factory</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="s">"config.ini"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"ERROR: init pegasus failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**succeed， continue**/</span>
</code></pre></div></div>
<p>注：</p>
<ul>
  <li>参数：config_file 见 配置文件 的介绍</li>
  <li>返回值：bool值，true代表初始化成功，false初始化失败</li>
  <li>该函数只需在一个进程生命周期内调用一次即可，并且非线程安全的</li>
</ul>

<p>获取客户端</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pegasus</span><span class="o">::</span><span class="n">pegasus_client</span><span class="o">*</span> <span class="n">pg_client</span> <span class="o">=</span> <span class="n">pegasus</span><span class="o">::</span><span class="n">pegasus_client_factory</span><span class="o">::</span><span class="n">get_client</span><span class="p">(</span><span class="s">"cluster_name"</span><span class="p">,</span> <span class="s">"table_name"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pg_client</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"ERROR: get pegasus client failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/***  do what you want with pg_client ****/</span>
</code></pre></div></div>
<p>注意： get_client返回值不能明确的调用delete，也不能用智能指针封装，框架在停止的时候自动释放（底层使用单例来保存）</p>

<h2 id="pegasus_client接口">pegasus_client接口</h2>
<p>Cpp客户端提供两种接口，异步API 和 同步API，同步API是基于异步API实现的，具体如下：</p>

<h3 id="set">set</h3>
<p>写单行数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief set</span>
    <span class="c1">///     store the k-v to the cluster.</span>
    <span class="c1">///     key is composed of hashkey and sortkey.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to put this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param value</span>
    <span class="c1">/// the value we want to store.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \param ttl_seconds</span>
    <span class="c1">/// time to live of this value, if expired, will return not found; 0 means no ttl</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string()</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">ttl_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>
<p>注：</p>
<ul>
  <li>internal_info 结构如下，主要是记录在写入成功之后，该条数据的一些信息，在使用之前需要判断info是否为空
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">struct</span> <span class="nc">internal_info</span>
 <span class="p">{</span>
     <span class="kt">int32_t</span> <span class="n">app_id</span><span class="p">;</span>
     <span class="kt">int32_t</span> <span class="n">partition_index</span><span class="p">;</span>
     <span class="kt">int64_t</span> <span class="n">decree</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">server</span><span class="p">;</span>
     <span class="n">internal_info</span><span class="p">()</span> <span class="o">:</span> <span class="n">app_id</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">partition_index</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">decree</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>返回值：int值来表示是否成功，通过get_error_string() 函数来判断返回值的意义（下面的所有同步接口的返回值，都可以通过该函数判断返回值意义）
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">///</span>
 <span class="c1">/// \brief get_error_string</span>
 <span class="c1">/// get error string</span>
 <span class="c1">/// all the function above return an int value that indicates an error can be converted into a</span>
 <span class="c1">/// string for human reading.</span>
 <span class="c1">/// \param error_code</span>
 <span class="c1">/// all the error code are defined in "error_def.h"</span>
 <span class="c1">/// \return</span>
 <span class="c1">///</span>
 <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">get_error_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">error_code</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>    </div>
    <h3 id="async_set">async_set</h3>
    <p>异步写单行数据</p>
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">///</span>
 <span class="c1">/// \brief asynchronous set</span>
 <span class="c1">///     store the k-v to the cluster.</span>
 <span class="c1">///     will not be blocked, return immediately.</span>
 <span class="c1">///     key is composed of hashkey and sortkey.</span>
 <span class="c1">/// \param hashkey</span>
 <span class="c1">/// used to decide which partition to put this k-v</span>
 <span class="c1">/// \param sortkey</span>
 <span class="c1">/// all the k-v under hashkey will be stored by sortkey.</span>
 <span class="c1">/// \param value</span>
 <span class="c1">/// the value we want to store.</span>
 <span class="c1">/// \param callback</span>
 <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
 <span class="c1">/// \param timeout_milliseconds</span>
 <span class="c1">/// if wait longer than this value, will return time out error.</span>
 <span class="c1">/// \param ttl_seconds</span>
 <span class="c1">/// time to live of this value, if expired, will return not found; 0 means no ttl.</span>
 <span class="c1">/// \return</span>
 <span class="c1">/// void.</span>
 <span class="c1">///</span>
 <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">async_set_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">ttl_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="multi_set">multi_set</h3>
<p>写多条数据（同一hashkey下面）</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief multi_set (guarantee atomicity)</span>
    <span class="c1">///     store multiple k-v of the same hashkey to the cluster.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to put this k-v</span>
    <span class="c1">/// \param kvs</span>
    <span class="c1">/// all &lt;sortkey,value&gt; pairs to be set. should not be empty</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \param ttl_seconds</span>
    <span class="c1">/// time to live of this value, if expired, will return not found; 0 means no ttl</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">/// return PERR_INVALID_ARGUMENT if param kvs is empty.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">multi_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">kvs</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">ttl_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_multi_set">async_multi_set</h3>
<p>异步写多条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous multi_set (guarantee atomicity)</span>
    <span class="c1">///     store multiple k-v of the same hashkey to the cluster.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to put this k-v</span>
    <span class="c1">/// \param kvs</span>
    <span class="c1">/// all &lt;sortkey,value&gt; pairs to be set. should not be empty</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \param ttl_seconds</span>
    <span class="c1">/// time to live of this value, if expired, will return not found; 0 means no ttl</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_multi_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">kvs</span><span class="p">,</span>
                                 <span class="n">async_multi_set_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">ttl_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="get">get</h3>
<p>读取一条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief get</span>
    <span class="c1">///     get value by key from the cluster.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param value</span>
    <span class="c1">/// the returned value will be put into it.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">/// returns PERR_NOT_FOUND if no value is found under the &lt;hashkey,sortkey&gt;.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                    <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_get">async_get</h3>
<p>异步读取一条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous get</span>
    <span class="c1">///     get value by key from the cluster.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_get</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                           <span class="n">async_get_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="multi_get">multi_get</h3>
<p>读取多条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief multi_get</span>
    <span class="c1">///     get multiple value by key from the cluster.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkeys</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// if empty, means fetch all sortkeys under the hashkey.</span>
    <span class="c1">/// \param values</span>
    <span class="c1">/// the returned &lt;sortkey,value&gt; pairs will be put into it.</span>
    <span class="c1">/// if data is not found for some &lt;hashkey,sortkey&gt;, then it will not appear in the map.</span>
    <span class="c1">/// \param max_fetch_count</span>
    <span class="c1">/// max count of k-v pairs to be fetched. max_fetch_count &lt;= 0 means no limit.</span>
    <span class="c1">/// \param max_fetch_size</span>
    <span class="c1">/// max size of k-v pairs to be fetched. max_fetch_size &lt;= 0 means no limit.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">/// returns PERR_OK if fetch done, even no data is returned.</span>
    <span class="c1">/// returns PERR_INCOMPLETE is only partial data is fetched.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">multi_get</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sortkeys</span><span class="p">,</span>
                          <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">max_fetch_count</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">max_fetch_size</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                          <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>
<p>注：max_fetch_count 和 max_fetch_size 分别从kv-pair的条数 和 总的大小来限制multi_get的返回值</p>

<h3 id="async_multi_get">async_multi_get</h3>
<p>异步读取多条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous multi_get</span>
    <span class="c1">///     get multiple value by key from the cluster.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkeys</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// if empty, means fetch all sortkeys under the hashkey.</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param max_fetch_count</span>
    <span class="c1">/// max count of k-v pairs to be fetched. max_fetch_count &lt;= 0 means no limit.</span>
    <span class="c1">/// \param max_fetch_size</span>
    <span class="c1">/// max size of k-v pairs to be fetched. max_fetch_size &lt;= 0 means no limit.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_multi_get</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sortkeys</span><span class="p">,</span>
                                 <span class="n">async_multi_get_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">max_fetch_count</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">max_fetch_size</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="multi_get_sortkeys">multi_get_sortkeys</h3>
<p>获取hashkey下面的多个sortkey，不返回value</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief multi_get_sortkeys</span>
    <span class="c1">///     get multiple sort keys by hash key from the cluster.</span>
    <span class="c1">///     only fetch sort keys, but not fetch values.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkeys</span>
    <span class="c1">/// the returned sort keys will be put into it.</span>
    <span class="c1">/// \param max_fetch_count</span>
    <span class="c1">/// max count of sort keys to be fetched. max_fetch_count &lt;= 0 means no limit.</span>
    <span class="c1">/// \param max_fetch_size</span>
    <span class="c1">/// max size of sort keys to be fetched. max_fetch_size &lt;= 0 means no limit.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">/// returns PERR_OK if fetch done, even no data is returned.</span>
    <span class="c1">/// returns PERR_INCOMPLETE is only partial data is fetched.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">multi_get_sortkeys</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                                   <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sortkeys</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">max_fetch_count</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">max_fetch_size</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                                   <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>
<p>注：max_fetch_count 和 max_fetch_size 分别限制返回的sortkey的个数与总大小（计算大小的时候，为每条sortkey都计算一次hashkey的大小）</p>

<h3 id="async_multi_get_sortkeys">async_multi_get_sortkeys</h3>
<p>异步获取hashkey下面的多个sortkey（不包含value）</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous multi_get_sortkeys</span>
    <span class="c1">///     get multiple sort keys by hash key from the cluster.</span>
    <span class="c1">///     only fetch sort keys, but not fetch values.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param max_fetch_count</span>
    <span class="c1">/// max count of sort keys to be fetched. max_fetch_count &lt;= 0 means no limit.</span>
    <span class="c1">/// \param max_fetch_size</span>
    <span class="c1">/// max size of sort keys to be fetched. max_fetch_size &lt;= 0 means no limit.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_multi_get_sortkeys</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                                          <span class="n">async_multi_get_sortkeys_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                                          <span class="kt">int</span> <span class="n">max_fetch_count</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                          <span class="kt">int</span> <span class="n">max_fetch_size</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span>
                                          <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="exist">exist</h3>
<p>判断单条数据是否存在</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief exist</span>
    <span class="c1">///     check value exist by key from the cluster.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">/// returns PERR_OK if exist.</span>
    <span class="c1">/// returns PERR_NOT_FOUND if not exist.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">exist</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                      <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                      <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="sortkey_count">sortkey_count</h3>
<p>统计hashkey下面的sortkey个数</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief sortkey_count</span>
    <span class="c1">///     get sortkey count by hashkey from the cluster.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param count</span>
    <span class="c1">/// the returned sortkey count</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">sortkey_count</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                              <span class="kt">int64_t</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span>
                              <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                              <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="del">del</h3>
<p>删除单条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief del</span>
    <span class="c1">///     del stored k-v by key from cluster</span>
    <span class="c1">///     key is composed of hashkey and sortkey. must provide both to get the value.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide from which partition to del this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string()</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">del</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                    <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_del">async_del</h3>
<p>异步删除单条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous del</span>
    <span class="c1">///     del stored k-v by key from cluster</span>
    <span class="c1">///     key is composed of hashkey and sortkey. must provide both to get the value.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide from which partition to del this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_del</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                           <span class="n">async_del_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="multi_del">multi_del</h3>
<p>删除多条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief multi_del</span>
    <span class="c1">///     delete multiple value by key from the cluster.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkeys</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey. should not be empty.</span>
    <span class="c1">/// \param deleted_count</span>
    <span class="c1">/// return count of deleted k-v pairs.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">multi_del</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sortkeys</span><span class="p">,</span>
                          <span class="kt">int64_t</span> <span class="o">&amp;</span><span class="n">deleted_count</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                          <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_multi_del">async_multi_del</h3>

<p>异步的删除多条数据</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous multi_del</span>
    <span class="c1">///     delete multiple value by key from the cluster.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkeys</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey. should not be empty.</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_multi_del</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sortkeys</span><span class="p">,</span>
                                 <span class="n">async_multi_del_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="incr">incr</h3>

<p>自增</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief incr</span>
    <span class="c1">///     atomically increment value by key from the cluster.</span>
    <span class="c1">///     key is composed of hashkey and sortkey. must provide both to get the value.</span>
    <span class="c1">///</span>
    <span class="c1">///     the increment semantic is the same as redis:</span>
    <span class="c1">///       - if old data is not found or empty, then set initial value to 0.</span>
    <span class="c1">///       - if old data is not an integer or out of range, then return PERR_INVALID_ARGUMENT,</span>
    <span class="c1">///         and return `new_value' as 0.</span>
    <span class="c1">///       - if new value is out of range, then return PERR_INVALID_ARGUMENT, and return old</span>
    <span class="c1">///         value in `new_value'.</span>
    <span class="c1">///</span>
    <span class="c1">///     if ttl_seconds == 0, the semantic is also the same as redis:</span>
    <span class="c1">///       - normally, increment will preserve the original ttl.</span>
    <span class="c1">///       - if old data is expired by ttl, then set initial value to 0 and set no ttl.</span>
    <span class="c1">///     if ttl_seconds &gt; 0, then update with the new ttl if incr succeed.</span>
    <span class="c1">///     if ttl_seconds == -1, then update to no ttl if incr succeed.</span>
    <span class="c1">///</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param increment</span>
    <span class="c1">/// the value we want to increment.</span>
    <span class="c1">/// \param new_value</span>
    <span class="c1">/// out param to return the new value if increment succeed.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \param ttl_seconds</span>
    <span class="c1">/// time to live of this value.</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">incr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="n">increment</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="o">&amp;</span><span class="n">new_value</span><span class="p">,</span>
                     <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                     <span class="kt">int</span> <span class="n">ttl_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                     <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_incr">async_incr</h3>

<p>异步自增</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous incr</span>
    <span class="c1">///     atomically increment value by key from the cluster.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">///</span>
    <span class="c1">///     the increment semantic is the same as redis:</span>
    <span class="c1">///       - if old data is not found or empty, then set initial value to 0.</span>
    <span class="c1">///       - if old data is not an integer or out of range, then return PERR_INVALID_ARGUMENT,</span>
    <span class="c1">///         and return `new_value' as 0.</span>
    <span class="c1">///       - if new value is out of range, then return PERR_INVALID_ARGUMENT, and return old</span>
    <span class="c1">///         value in `new_value'.</span>
    <span class="c1">///</span>
    <span class="c1">///     if ttl_seconds == 0, the semantic is also the same as redis:</span>
    <span class="c1">///       - normally, increment will preserve the original ttl.</span>
    <span class="c1">///       - if old data is expired by ttl, then set initial value to 0 and set no ttl.</span>
    <span class="c1">///     if ttl_seconds &gt; 0, then update with the new ttl if incr succeed.</span>
    <span class="c1">///     if ttl_seconds == -1, then update to no ttl if incr succeed.</span>
    <span class="c1">///</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param sortkey</span>
    <span class="c1">/// all the k-v under hashkey will be sorted by sortkey.</span>
    <span class="c1">/// \param increment</span>
    <span class="c1">/// the value we want to increment.</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \param ttl_seconds</span>
    <span class="c1">/// time to live of this value.</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_incr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sortkey</span><span class="p">,</span>
                            <span class="kt">int64_t</span> <span class="n">increment</span><span class="p">,</span>
                            <span class="n">async_incr_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">ttl_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="check_and_set">check_and_set</h3>

<p>检查并设置</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief check_and_set</span>
    <span class="c1">///     atomically check and set value by key from the cluster.</span>
    <span class="c1">///     the value will be set if and only if check passed.</span>
    <span class="c1">///     the sort key for checking and setting can be the same or different.</span>
    <span class="c1">/// \param hash_key</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param check_sort_key</span>
    <span class="c1">/// the sort key to check.</span>
    <span class="c1">/// \param check_type</span>
    <span class="c1">/// the check type.</span>
    <span class="c1">/// \param check_operand</span>
    <span class="c1">/// the check operand.</span>
    <span class="c1">/// \param set_sort_key</span>
    <span class="c1">/// the sort key to set value if check passed.</span>
    <span class="c1">/// \param set_value</span>
    <span class="c1">/// the value to set if check passed.</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// the check-and-set options.</span>
    <span class="c1">/// \param results</span>
    <span class="c1">/// the check-and-set results.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">/// if check type is int compare, and check_operand/check_value is not integer</span>
    <span class="c1">/// or out of range, then return PERR_INVALID_ARGUMENT.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">check_and_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hash_key</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_sort_key</span><span class="p">,</span>
                              <span class="n">cas_check_type</span> <span class="n">check_type</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_operand</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">set_sort_key</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">set_value</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">check_and_set_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                              <span class="n">check_and_set_results</span> <span class="o">&amp;</span><span class="n">results</span><span class="p">,</span>
                              <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                              <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_check_and_set">async_check_and_set</h3>

<p>异步检查并设置</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous check_and_set</span>
    <span class="c1">///     atomically check and set value by key from the cluster.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hash_key</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param check_sort_key</span>
    <span class="c1">/// the sort key to check.</span>
    <span class="c1">/// \param check_type</span>
    <span class="c1">/// the check type.</span>
    <span class="c1">/// \param check_operand</span>
    <span class="c1">/// the check operand.</span>
    <span class="c1">/// \param set_sort_key</span>
    <span class="c1">/// the sort key to set value if check passed.</span>
    <span class="c1">/// \param set_value</span>
    <span class="c1">/// the value to set if check passed.</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// the check-and-set options.</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_check_and_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hash_key</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_sort_key</span><span class="p">,</span>
                                     <span class="n">cas_check_type</span> <span class="n">check_type</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_operand</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">set_sort_key</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">set_value</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">check_and_set_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                                     <span class="n">async_check_and_set_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                                     <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="check_and_mutate">check_and_mutate</h3>

<p>检查并修改</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief check_and_mutate</span>
    <span class="c1">///     atomically check and mutate from the cluster.</span>
    <span class="c1">///     the mutations will be applied if and only if check passed.</span>
    <span class="c1">/// \param hash_key</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param check_sort_key</span>
    <span class="c1">/// the sort key to check.</span>
    <span class="c1">/// \param check_type</span>
    <span class="c1">/// the check type.</span>
    <span class="c1">/// \param check_operand</span>
    <span class="c1">/// the check operand.</span>
    <span class="c1">/// \param mutations</span>
    <span class="c1">/// the list of mutations to perform if check condition is satisfied.</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// the check-and-mutate options.</span>
    <span class="c1">/// \param results</span>
    <span class="c1">/// the check-and-mutate results.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string().</span>
    <span class="c1">/// if check type is int compare, and check_operand/check_value is not integer</span>
    <span class="c1">/// or out of range, then return PERR_INVALID_ARGUMENT.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">check_and_mutate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hash_key</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_sort_key</span><span class="p">,</span>
                                 <span class="n">cas_check_type</span> <span class="n">check_type</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_operand</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">mutations</span> <span class="o">&amp;</span><span class="n">mutations</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">check_and_mutate_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                                 <span class="n">check_and_mutate_results</span> <span class="o">&amp;</span><span class="n">results</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                                 <span class="n">internal_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

</code></pre></div></div>

<h3 id="async_check_and_mutate">async_check_and_mutate</h3>

<p>异步检查并修改</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief asynchronous check_and_mutate</span>
    <span class="c1">///     atomically check and mutate from the cluster.</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hash_key</span>
    <span class="c1">/// used to decide which partition to get this k-v</span>
    <span class="c1">/// \param check_sort_key</span>
    <span class="c1">/// the sort key to check.</span>
    <span class="c1">/// \param check_type</span>
    <span class="c1">/// the check type.</span>
    <span class="c1">/// \param check_operand</span>
    <span class="c1">/// the check operand.</span>
    <span class="c1">/// \param mutations</span>
    <span class="c1">/// the list of mutations to perform if check condition is satisfied.</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// the check-and-mutate options.</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// the callback function will be invoked after operation finished or error occurred.</span>
    <span class="c1">/// \param timeout_milliseconds</span>
    <span class="c1">/// if wait longer than this value, will return time out error</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// void.</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">async_check_and_mutate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hash_key</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_sort_key</span><span class="p">,</span>
                                        <span class="n">cas_check_type</span> <span class="n">check_type</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">check_operand</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">mutations</span> <span class="o">&amp;</span><span class="n">mutations</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">check_and_mutate_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                                        <span class="n">async_check_and_mutate_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                                        <span class="kt">int</span> <span class="n">timeout_milliseconds</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="ttl">ttl</h3>

<p>获取单行数据的TTL时间。TTL表示Time To Live，表示该数据还能存活多久。如果超过存活时间，数据就读不到了</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief ttl (time to live)
    ///     get ttl in seconds of this k-v.
    ///     key is composed of hashkey and sortkey. must provide both to get the value.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param ttl_seconds
    /// the returned ttl value in seconds.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string()
    ///
    virtual int ttl(const std::string &amp;hashkey,
                    const std::string &amp;sortkey,
                    int &amp;ttl_seconds,
                    int timeout_milliseconds = 5000,
                    internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="get_scanner">get_scanner</h3>
<p>获取针对某个hashkey下的sortkey区间 [sortkeyA ~ sortkeyB)的一个scanner</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief get hash scanner</span>
    <span class="c1">///     get scanner for [start_sortkey, stop_sortkey) of hashkey</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// cannot be empty</span>
    <span class="c1">/// \param start_sortkey</span>
    <span class="c1">/// sortkey to start with</span>
    <span class="c1">/// \param stop_sortkey</span>
    <span class="c1">/// sortkey to stop. ""(empty string) represents the max key</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// which used to indicate scan options, like which bound is inclusive</span>
    <span class="c1">/// \param scanner</span>
    <span class="c1">/// out param, used to get k-v</span>
    <span class="c1">/// this pointer should be deleted when scan complete</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string()</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">get_scanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">start_sortkey</span><span class="p">,</span> <span class="c1">// start from beginning if this set ""</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">stop_sortkey</span><span class="p">,</span>  <span class="c1">// to the last item if this set ""</span>
                            <span class="k">const</span> <span class="n">scan_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                            <span class="n">pegasus_scanner</span> <span class="o">*&amp;</span><span class="n">scanner</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_get_scanner">async_get_scanner</h3>
<p>异步获取针对某个hashkey下的sortkey区间 [sortkeyA ~ sortkeyB)的一个scanner</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief async get hash scanner</span>
    <span class="c1">///     get scanner for [start_sortkey, stop_sortkey) of hashkey</span>
    <span class="c1">///     will not be blocked, return immediately.</span>
    <span class="c1">/// \param hashkey</span>
    <span class="c1">/// cannot be empty</span>
    <span class="c1">/// \param start_sortkey</span>
    <span class="c1">/// sortkey to start with</span>
    <span class="c1">/// \param stop_sortkey</span>
    <span class="c1">/// sortkey to stop. ""(empty string) represents the max key</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// which used to indicate scan options, like which bound is inclusive</span>
    <span class="c1">/// \param callback</span>
    <span class="c1">/// return status and scanner in callback, and the latter should be deleted when scan complete</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span>
    <span class="n">async_get_scanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">hashkey</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">start_sortkey</span><span class="p">,</span> <span class="c1">// start from beginning if this set ""</span>
                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">stop_sortkey</span><span class="p">,</span>  <span class="c1">// to the last item if this set ""</span>
                      <span class="k">const</span> <span class="n">scan_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                      <span class="n">async_get_scanner_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="get_unordered_scanners">get_unordered_scanners</h3>
<p>获取一个遍历所有数据的scanner</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief get a bundle of scanners to iterate all k-v in table</span>
    <span class="c1">///        scanners should be deleted when scan complete</span>
    <span class="c1">/// \param max_split_count</span>
    <span class="c1">/// the number of scanners returned will always &lt;= max_split_count</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// which used to indicate scan options, like timeout_milliseconds</span>
    <span class="c1">/// \param scanners</span>
    <span class="c1">/// out param, used to get k-v</span>
    <span class="c1">/// these pointers should be deleted</span>
    <span class="c1">/// \return</span>
    <span class="c1">/// int, the error indicates whether or not the operation is succeeded.</span>
    <span class="c1">/// this error can be converted to a string using get_error_string()</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">get_unordered_scanners</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_split_count</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">scan_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                                       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pegasus_scanner</span> <span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">scanners</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="async_get_unordered_scanners">async_get_unordered_scanners</h3>
<p>异步获取一个遍历所有数据的scanner</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">///</span>
    <span class="c1">/// \brief async get a bundle of scanners to iterate all k-v in table</span>
    <span class="c1">///        scannners return by callback should be deleted when all scan complete</span>
    <span class="c1">/// \param max_split_count</span>
    <span class="c1">/// the number of scanners returned will always &lt;= max_split_count</span>
    <span class="c1">/// \param options</span>
    <span class="c1">/// which used to indicate scan options, like timeout_milliseconds</span>
    <span class="c1">/// \param callback; return status and scanner in this callback</span>
    <span class="c1">///</span>
    <span class="k">virtual</span> <span class="kt">void</span>
    <span class="n">async_get_unordered_scanners</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_split_count</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">scan_options</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                                 <span class="n">async_get_unordered_scanners_callback_t</span> <span class="o">&amp;&amp;</span><span class="n">callback</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

                </div>
            </section>
            <footer class="footer">
    <div class="container">
        <div class="content is-small has-text-centered">
            <div style="margin-bottom: 20px;">
                <a href="http://incubator.apache.org">
                    <img src="/assets/images/egg-logo.png"
                         width="15%"
                         alt="Apache Incubator"/>
                </a>
            </div>
            Copyright &copy; 2023 <a href="http://www.apache.org">The Apache Software Foundation</a>.
            Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version
            2.0</a>.
            <br><br>
            
            Apache Pegasus is an effort undergoing incubation at The Apache Software Foundation (ASF),
            sponsored by the Apache Incubator. Incubation is required of all newly accepted projects
            until a further review indicates that the infrastructure, communications, and decision making process
            have stabilized in a manner consistent with other successful ASF projects. While incubation status is
            not necessarily a reflection of the completeness or stability of the code, it does indicate that the
            project has yet to be fully endorsed by the ASF.
            
            <br><br>
            Apache Pegasus, Pegasus, Apache, the Apache feather logo, and the Apache Pegasus project logo are either
            registered trademarks or trademarks of The Apache Software Foundation in the United States and other
            countries.
        </div>
    </div>
</footer>
        </div>

        <!-- right panel -->
        <div class="dashboard-panel is-small is-scrollable is-hidden-mobile">
            <p class="menu-label">
    <span class="icon">
        <i class="fa fa-bars" aria-hidden="true"></i>
    </span>
    本页导航
</p>
<ul class="menu-list">
  <li><a href="#获取cpp客户端">获取Cpp客户端</a></li>
  <li><a href="#配置文件">配置文件</a></li>
  <li><a href="#接口定义">接口定义</a>
    <ul>
      <li><a href="#创建client实例">创建Client实例</a></li>
      <li><a href="#pegasus_client接口">pegasus_client接口</a>
        <ul>
          <li><a href="#set">set</a></li>
          <li><a href="#async_set">async_set</a></li>
          <li><a href="#multi_set">multi_set</a></li>
          <li><a href="#async_multi_set">async_multi_set</a></li>
          <li><a href="#get">get</a></li>
          <li><a href="#async_get">async_get</a></li>
          <li><a href="#multi_get">multi_get</a></li>
          <li><a href="#async_multi_get">async_multi_get</a></li>
          <li><a href="#multi_get_sortkeys">multi_get_sortkeys</a></li>
          <li><a href="#async_multi_get_sortkeys">async_multi_get_sortkeys</a></li>
          <li><a href="#exist">exist</a></li>
          <li><a href="#sortkey_count">sortkey_count</a></li>
          <li><a href="#del">del</a></li>
          <li><a href="#async_del">async_del</a></li>
          <li><a href="#multi_del">multi_del</a></li>
          <li><a href="#async_multi_del">async_multi_del</a></li>
          <li><a href="#incr">incr</a></li>
          <li><a href="#async_incr">async_incr</a></li>
          <li><a href="#check_and_set">check_and_set</a></li>
          <li><a href="#async_check_and_set">async_check_and_set</a></li>
          <li><a href="#check_and_mutate">check_and_mutate</a></li>
          <li><a href="#async_check_and_mutate">async_check_and_mutate</a></li>
          <li><a href="#ttl">ttl</a></li>
          <li><a href="#get_scanner">get_scanner</a></li>
          <li><a href="#async_get_scanner">async_get_scanner</a></li>
          <li><a href="#get_unordered_scanners">get_unordered_scanners</a></li>
          <li><a href="#async_get_unordered_scanners">async_get_unordered_scanners</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

        </div>
    </div>

    <script src="/assets/js/app.js" type="text/javascript"></script>
     <script>
     docsearch({
         container: '#docsearch',
         appId: 'QRN30RBW0S',
         indexName: 'pegasus-apache',
         apiKey: 'd3a3252fa344359766707a106c4ed88f',
         debug: true
     });
 </script>

</body>

</html>