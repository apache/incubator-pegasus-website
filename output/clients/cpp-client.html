<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pegasus | Cpp Client</title>
    <link rel="stylesheet" href="/assets/css/app.css">
    <link rel="shortcut icon" href="/assets/images/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/tailwindcss/1.8.10/utilities.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script>
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Cpp Client | Pegasus</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Cpp Client" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="获取Cpp客户端 首先需要编译Pegasus，编译完成后运行以下命令可以打包生产Cpp客户端库： ./run.sh pack_client 运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。" />
<meta property="og:description" content="获取Cpp客户端 首先需要编译Pegasus，编译完成后运行以下命令可以打包生产Cpp客户端库： ./run.sh pack_client 运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。" />
<meta property="og:site_name" content="Pegasus" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-26T02:33:28+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Cpp Client" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Cpp Client","dateModified":"2021-07-26T02:33:28+00:00","datePublished":"2021-07-26T02:33:28+00:00","url":"/clients/cpp-client","mainEntityOfPage":{"@type":"WebPage","@id":"/clients/cpp-client"},"description":"获取Cpp客户端 首先需要编译Pegasus，编译完成后运行以下命令可以打包生产Cpp客户端库： ./run.sh pack_client 运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
</head>


<body>
    <div class="dashboard is-full-height">
        <!-- left panel -->
        <div class="dashboard-panel is-medium is-hidden-mobile pl-0">
            <div class="dashboard-panel-header has-text-centered">
                <a href="/">
                    <img src="/assets/images/pegasus-logo-inv.png" style="width: 80%;">
                </a>
                
            </div>
            <div class="dashboard-panel-main is-scrollable pl-6">
                

<aside class="menu">
    
    <p class="menu-label">Pegasus产品文档</p>
    <ul class="menu-list">
        
        <li>
            <a href="/docs/downloads"
                class="">
                下载
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">编译构建</p>
    <ul class="menu-list">
        
        <li>
            <a href="/docs/build/compile-by-docker"
                class="">
                使用Docker完成编译（推荐）
            </a>
        </li>
        
        <li>
            <a href="/docs/build/compile-from-source"
                class="">
                从源码编译
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">客户端库</p>
    <ul class="menu-list">
        
        <li>
            <a href="/clients/java-client"
                class="">
                Java客户端
            </a>
        </li>
        
        <li>
            <a href="/clients/cpp-client"
                class="is-active">
                C++客户端
            </a>
        </li>
        
        <li>
            <a href="https://github.com/XiaoMi/pegasus-go-client"
                class="">
                Golang客户端
            </a>
        </li>
        
        <li>
            <a href="/clients/python2-client"
                class="">
                Python2客户端
            </a>
        </li>
        
        <li>
            <a href="/clients/python3-client"
                class="">
                Python3客户端
            </a>
        </li>
        
        <li>
            <a href="/clients/node-client"
                class="">
                NodeJS客户端
            </a>
        </li>
        
        <li>
            <a href="/clients/scala-client"
                class="">
                Scala客户端
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">生态工具</p>
    <ul class="menu-list">
        
        <li>
            <a href="/docs/tools/shell"
                class="">
                Pegasus Shell 工具
            </a>
        </li>
        
        <li>
            <a href="https://github.com/pegasus-kv/admin-cli"
                class="">
                集群管理命令行
            </a>
        </li>
        
        <li>
            <a href="https://github.com/pegasus-kv/pegic"
                class="">
                数据访问命令行
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">用户接口</p>
    <ul class="menu-list">
        
        <li>
            <a href="/api/ttl"
                class="">
                TTL
            </a>
        </li>
        
        <li>
            <a href="/api/single-atomic"
                class="">
                单行原子操作
            </a>
        </li>
        
        <li>
            <a href="/api/redis"
                class="">
                Redis适配
            </a>
        </li>
        
        <li>
            <a href="/api/geo"
                class="">
                GEO支持
            </a>
        </li>
        
        <li>
            <a href="/api/http"
                class="">
                HTTP接口
            </a>
        </li>
        
    </ul>
    
    <p class="menu-label">高效运维</p>
    <ul class="menu-list">
        
        <li>
            <a href="/administration/deployment"
                class="">
                集群部署
            </a>
        </li>
        
        <li>
            <a href="/administration/config"
                class="">
                配置说明
            </a>
        </li>
        
        <li>
            <a href="/administration/rebalance"
                class="">
                负载均衡
            </a>
        </li>
        
        <li>
            <a href="/administration/monitoring"
                class="">
                可视化监控
            </a>
        </li>
        
        <li>
            <a href="/administration/rolling-update"
                class="">
                集群升级
            </a>
        </li>
        
        <li>
            <a href="/administration/scale-in-out"
                class="">
                集群扩容缩容
            </a>
        </li>
        
        <li>
            <a href="/administration/resource-management"
                class="">
                资源管理
            </a>
        </li>
        
        <li>
            <a href="/administration/cold-backup"
                class="">
                冷备份
            </a>
        </li>
        
        <li>
            <a href="/administration/meta-recovery"
                class="">
                元数据恢复
            </a>
        </li>
        
        <li>
            <a href="/administration/replica-recovery"
                class="">
                Replica数据恢复
            </a>
        </li>
        
        <li>
            <a href="/administration/zk-migration"
                class="">
                Zookeeper迁移
            </a>
        </li>
        
        <li>
            <a href="/administration/table-migration"
                class="">
                Table迁移
            </a>
        </li>
        
        <li>
            <a href="/administration/table-soft-delete"
                class="">
                Table软删除
            </a>
        </li>
        
        <li>
            <a href="/administration/table-env"
                class="">
                Table环境变量
            </a>
        </li>
        
        <li>
            <a href="/administration/remote-commands"
                class="">
                远程命令
            </a>
        </li>
        
        <li>
            <a href="/administration/partition-split"
                class="">
                Partition-Split
            </a>
        </li>
        
        <li>
            <a href="/administration/duplication"
                class="">
                跨机房同步
            </a>
        </li>
        
        <li>
            <a href="/administration/compression"
                class="">
                数据压缩
            </a>
        </li>
        
        <li>
            <a href="/administration/throttling"
                class="">
                流量控制
            </a>
        </li>
        
        <li>
            <a href="/administration/experiences"
                class="">
                运维经验
            </a>
        </li>
        
        <li>
            <a href="/administration/manual-compact"
                class="">
                Manual Compact功能
            </a>
        </li>
        
        <li>
            <a href="/administration/usage-scenario"
                class="">
                Usage Scenario功能
            </a>
        </li>
        
        <li>
            <a href="/administration/bad-disk"
                class="">
                坏盘检修
            </a>
        </li>
        
        <li>
            <a href="/administration/whitelist"
                class="">
                白名单
            </a>
        </li>
        
        <li>
            <a href="/administration/backup-request"
                class="">
                Backup Request
            </a>
        </li>
        
        <li>
            <a href="/administration/hotspot-detection"
                class="">
                热点检测
            </a>
        </li>
        
    </ul>
    
</aside>
            </div>
        </div>

        <!-- main section -->
        <div class="dashboard-main is-scrollable">
            <nav class="navbar is-hidden-desktop">
    <div class="navbar-brand">
        <a href="/" class="navbar-item">
            <!-- Pegasus Icon -->
            <img src="/assets/images/pegasus-square.png">
        </a>
        <div class="navbar-item">
            

<!--A simple language switch button that only supports zh and en.-->
<!--IF its language is zh, then switches to en.-->

<a class="button is-light is-outlined is-inverted" href="/en/clients/cpp-client"><strong>En</strong></a>

        </div>
        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navMenu">
            <!-- Appears in mobile mode only -->
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
    </div>
    <div class="navbar-menu" id="navMenu">
        <div class="navbar-end">
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        Pegasus产品文档
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/docs/downloads"
                        class="navbar-item ">
                        下载
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        编译构建
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/docs/build/compile-by-docker"
                        class="navbar-item ">
                        使用Docker完成编译（推荐）
                    </a>
                    
                    <a href="/docs/build/compile-from-source"
                        class="navbar-item ">
                        从源码编译
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        客户端库
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/clients/java-client"
                        class="navbar-item ">
                        Java客户端
                    </a>
                    
                    <a href="/clients/cpp-client"
                        class="navbar-item is-active">
                        C++客户端
                    </a>
                    
                    <a href="https://github.com/XiaoMi/pegasus-go-client"
                        class="navbar-item ">
                        Golang客户端
                    </a>
                    
                    <a href="/clients/python2-client"
                        class="navbar-item ">
                        Python2客户端
                    </a>
                    
                    <a href="/clients/python3-client"
                        class="navbar-item ">
                        Python3客户端
                    </a>
                    
                    <a href="/clients/node-client"
                        class="navbar-item ">
                        NodeJS客户端
                    </a>
                    
                    <a href="/clients/scala-client"
                        class="navbar-item ">
                        Scala客户端
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        生态工具
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/docs/tools/shell"
                        class="navbar-item ">
                        Pegasus Shell 工具
                    </a>
                    
                    <a href="https://github.com/pegasus-kv/admin-cli"
                        class="navbar-item ">
                        集群管理命令行
                    </a>
                    
                    <a href="https://github.com/pegasus-kv/pegic"
                        class="navbar-item ">
                        数据访问命令行
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        用户接口
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/api/ttl"
                        class="navbar-item ">
                        TTL
                    </a>
                    
                    <a href="/api/single-atomic"
                        class="navbar-item ">
                        单行原子操作
                    </a>
                    
                    <a href="/api/redis"
                        class="navbar-item ">
                        Redis适配
                    </a>
                    
                    <a href="/api/geo"
                        class="navbar-item ">
                        GEO支持
                    </a>
                    
                    <a href="/api/http"
                        class="navbar-item ">
                        HTTP接口
                    </a>
                    
                </div>
            </div>
            
            <!--dropdown-->
            <div class="navbar-item has-dropdown is-hoverable">
                <a href=""
                    class="navbar-link ">
                    <span>
                        高效运维
                    </span>
                </a>
                <div class="navbar-dropdown">
                    
                    <a href="/administration/deployment"
                        class="navbar-item ">
                        集群部署
                    </a>
                    
                    <a href="/administration/config"
                        class="navbar-item ">
                        配置说明
                    </a>
                    
                    <a href="/administration/rebalance"
                        class="navbar-item ">
                        负载均衡
                    </a>
                    
                    <a href="/administration/monitoring"
                        class="navbar-item ">
                        可视化监控
                    </a>
                    
                    <a href="/administration/rolling-update"
                        class="navbar-item ">
                        集群升级
                    </a>
                    
                    <a href="/administration/scale-in-out"
                        class="navbar-item ">
                        集群扩容缩容
                    </a>
                    
                    <a href="/administration/resource-management"
                        class="navbar-item ">
                        资源管理
                    </a>
                    
                    <a href="/administration/cold-backup"
                        class="navbar-item ">
                        冷备份
                    </a>
                    
                    <a href="/administration/meta-recovery"
                        class="navbar-item ">
                        元数据恢复
                    </a>
                    
                    <a href="/administration/replica-recovery"
                        class="navbar-item ">
                        Replica数据恢复
                    </a>
                    
                    <a href="/administration/zk-migration"
                        class="navbar-item ">
                        Zookeeper迁移
                    </a>
                    
                    <a href="/administration/table-migration"
                        class="navbar-item ">
                        Table迁移
                    </a>
                    
                    <a href="/administration/table-soft-delete"
                        class="navbar-item ">
                        Table软删除
                    </a>
                    
                    <a href="/administration/table-env"
                        class="navbar-item ">
                        Table环境变量
                    </a>
                    
                    <a href="/administration/remote-commands"
                        class="navbar-item ">
                        远程命令
                    </a>
                    
                    <a href="/administration/partition-split"
                        class="navbar-item ">
                        Partition-Split
                    </a>
                    
                    <a href="/administration/duplication"
                        class="navbar-item ">
                        跨机房同步
                    </a>
                    
                    <a href="/administration/compression"
                        class="navbar-item ">
                        数据压缩
                    </a>
                    
                    <a href="/administration/throttling"
                        class="navbar-item ">
                        流量控制
                    </a>
                    
                    <a href="/administration/experiences"
                        class="navbar-item ">
                        运维经验
                    </a>
                    
                    <a href="/administration/manual-compact"
                        class="navbar-item ">
                        Manual Compact功能
                    </a>
                    
                    <a href="/administration/usage-scenario"
                        class="navbar-item ">
                        Usage Scenario功能
                    </a>
                    
                    <a href="/administration/bad-disk"
                        class="navbar-item ">
                        坏盘检修
                    </a>
                    
                    <a href="/administration/whitelist"
                        class="navbar-item ">
                        白名单
                    </a>
                    
                    <a href="/administration/backup-request"
                        class="navbar-item ">
                        Backup Request
                    </a>
                    
                    <a href="/administration/hotspot-detection"
                        class="navbar-item ">
                        热点检测
                    </a>
                    
                </div>
            </div>
            
        </div>
    </div>
</nav>

<nav class="navbar is-hidden-mobile">
    <div class="navbar-start w-full">
        <div class="navbar-item pl-0 w-full">
            <!--TODO(wutao): Given the limitation of docsearch that couldn't handle multiple input,
                I make searchbox only shown in desktop. Fix this issue when docsearch.js v3 released.
                Related issue: https://github.com/algolia/docsearch/issues/230-->
            <div class="navbar-searchbox w-full bg-gray-200">
    <div class="field">
        <div class="control has-icons-right">
            <input class="input searchbox-input focus:placeholder-transparent"
                type="text" placeholder="Search the docs">
            <span class="icon is-right">
                <i class="fas fa-search searchbox-icon"></i>
            </span>
        </div>
    </div>
</div>
        </div>
    </div>
    <div class="navbar-end">
        <div class="navbar-item">
            

<!--A simple language switch button that only supports zh and en.-->
<!--IF its language is zh, then switches to en.-->

<a class="button is-light is-outlined is-inverted" href="/en/clients/cpp-client"><strong>En</strong></a>

        </div>
    </div>
</nav>

            <section class="hero is-info lg:mr-3">
                <div class="hero-body">
                    
                    <p class="title is-size-2 is-centered">C++客户端</p>
                </div>
            </section>
            <section class="section" style="padding-top: 2rem;">
                <div class="content">
                    <h1 id="获取cpp客户端">获取Cpp客户端</h1>
<p>首先需要<a href="/overview/compilation">编译Pegasus</a>，编译完成后运行以下命令可以打包生产Cpp客户端库：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./run.sh pack_client
</code></pre></div></div>
<p>运行成功后，会在本地文件夹下生产pegasus-client-{version}-{platform}-{buildType}的文件夹以及tar.gz文件。在文件夹里面有个sample/文件夹，进去后可以运行make编译示例程序。</p>

<h1 id="配置文件">配置文件</h1>
<p>Cpp客户端由于使用了rdsn框架，所以配置文件较为复杂，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[apps..default]
run = true
count = 1
;network.client.RPC_CHANNEL_TCP = dsn::tools::sim_network_provider, 65536
;network.client.RPC_CHANNEL_UDP = dsn::tools::sim_network_provider, 65536
;network.server.0.RPC_CHANNEL_TCP = dsn::tools::sim_network_provider, 65536

[apps.mimic]
type = dsn.app.mimic
arguments =
pools = THREAD_POOL_DEFAULT
run = true
count = 1

[core]
;tool = simulator
;tool = fastrun
tool = nativerun
;toollets = tracer
;toollets = tracer, profiler, fault_injector
pause_on_start = false
cli_local = false
cli_remote = false

start_nfs = false

logging_start_level = LOG_LEVEL_DEBUG
logging_factory_name = dsn::tools::simple_logger
logging_flush_on_exit = true

enable_default_app_mimic = true

data_dir = ./data

[tools.simple_logger]
short_header = true
fast_flush = true
max_number_of_log_files_on_disk = 10
stderr_start_level = LOG_LEVEL_ERROR

[tools.hpc_logger]
per_thread_buffer_bytes = 8192
max_number_of_log_files_on_disk = 10

[tools.simulator]
random_seed = 0

[network]
; how many network threads for network library(used by asio)
io_service_worker_count = 4

; specification for each thread pool
[threadpool..default]
worker_count = 4

[threadpool.THREAD_POOL_DEFAULT]
name = default
partitioned = false
max_input_queue_length = 1024
worker_priority = THREAD_xPRIORITY_NORMAL
worker_count = 4

[task..default]
is_trace = false
is_profile = false
allow_inline = false
fast_execution_in_network_thread = false
rpc_call_header_format = NET_HDR_DSN
rpc_call_channel = RPC_CHANNEL_TCP
rpc_timeout_milliseconds = 5000

[pegasus.clusters]
onebox = @LOCAL_IP@:34601,@LOCAL_IP@:34602,@LOCAL_IP@:34603
another_cluster = @SOME_IP@:34601,@SOME_IP@:34601,@SOME_IP@:34601
</code></pre></div></div>
<p>配置文件的具体解释，请移步<a href="/administration/config">配置说明</a>。</p>

<h1 id="接口定义">接口定义</h1>
<h2 id="创建client实例">创建Client实例</h2>
<p>客户端工厂类</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namespace pegasus {
class pegasus_client_factory
{
public:
    ///
    /// \brief initialize
    /// initialize pegasus client lib. must call this function before anything else.
    /// \param config_file
    /// the configuration file of client lib
    /// \return
    /// true indicate the initailize is success.
    ///
    static bool initialize(const char *config_file);

    ///
    /// \brief get_client
    /// get an instance for a given cluster and a given app name.
    /// \param cluster_name
    /// the pegasus cluster name.
    /// a cluster can have multiple apps.
    /// \param app_name
    /// an app is a logical isolated k-v store.
    /// a cluster can have multiple apps.
    /// \return
    /// the client instance. DO NOT delete this client even after usage.
    static pegasus_client *get_client(const char *cluster_name, const char *app_name);
};
} //end namespace
</code></pre></div></div>
<p>客户端的初始化，实际上是对rdsn框架初始化</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!pegasus::pegasus_client_factory::initialize("config.ini")) {
    fprintf(stderr, "ERROR: init pegasus failed\n");
    return -1;
}
/**succeed， continue**/
</code></pre></div></div>
<p>注：</p>
<ul>
  <li>参数：config_file 见 配置文件 的介绍</li>
  <li>返回值：bool值，true代表初始化成功，false初始化失败</li>
  <li>该函数只需在一个进程生命周期内调用一次即可，并且非线程安全的</li>
</ul>

<p>获取客户端</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pegasus::pegasus_client* pg_client = pegasus::pegasus_client_factory::get_client("cluster_name", "table_name");
if (pg_client == nullptr) {
    fprintf(stderr, "ERROR: get pegasus client failed\n");
    return -1;
}
/***  do what you want with pg_client ****/
</code></pre></div></div>
<p>注意： get_client返回值不能明确的调用delete，也不能用智能指针封装，框架在停止的时候自动释放（底层使用单例来保存）</p>

<h2 id="pegasus_client接口">pegasus_client接口</h2>
<p>Cpp客户端提供两种接口，异步API 和 同步API，同步API是基于异步API实现的，具体如下：</p>

<h3 id="set">set</h3>
<p>写单行数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief set
    ///     store the k-v to the cluster.
    ///     key is composed of hashkey and sortkey.
    /// \param hashkey
    /// used to decide which partition to put this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param value
    /// the value we want to store.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \param ttl_seconds
    /// time to live of this value, if expired, will return not found; 0 means no ttl
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string()
    ///
    virtual int set(const std::string &amp;hashkey,
                    const std::string &amp;sortkey,
                    const std::string &amp;value,
                    int timeout_milliseconds = 5000,
                    int ttl_seconds = 0,
                    internal_info *info = NULL) = 0;
</code></pre></div></div>
<p>注：</p>
<ul>
  <li>internal_info 结构如下，主要是记录在写入成功之后，该条数据的一些信息，在使用之前需要判断info是否为空
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> struct internal_info
 {
     int32_t app_id;
     int32_t partition_index;
     int64_t decree;
     std::string server;
     internal_info() : app_id(-1), partition_index(-1), decree(-1) {}
  }
</code></pre></div>    </div>
  </li>
  <li>返回值：int值来表示是否成功，通过get_error_string() 函数来判断返回值的意义（下面的所有同步接口的返回值，都可以通过该函数判断返回值意义）
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ///
 /// \brief get_error_string
 /// get error string
 /// all the function above return an int value that indicates an error can be converted into a
 /// string for human reading.
 /// \param error_code
 /// all the error code are defined in "error_def.h"
 /// \return
 ///
 virtual const char *get_error_string(int error_code) const = 0;
</code></pre></div>    </div>
    <h3 id="async_set">async_set</h3>
    <p>异步写单行数据</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ///
 /// \brief asynchronous set
 ///     store the k-v to the cluster.
 ///     will not be blocked, return immediately.
 ///     key is composed of hashkey and sortkey.
 /// \param hashkey
 /// used to decide which partition to put this k-v
 /// \param sortkey
 /// all the k-v under hashkey will be stored by sortkey.
 /// \param value
 /// the value we want to store.
 /// \param callback
 /// the callback function will be invoked after operation finished or error occurred.
 /// \param timeout_milliseconds
 /// if wait longer than this value, will return time out error.
 /// \param ttl_seconds
 /// time to live of this value, if expired, will return not found; 0 means no ttl.
 /// \return
 /// void.
 ///
 virtual void async_set(const std::string &amp;hashkey,
                        const std::string &amp;sortkey,
                        const std::string &amp;value,
                        async_set_callback_t &amp;&amp;callback = nullptr,
                        int timeout_milliseconds = 5000,
                        int ttl_seconds = 0) = 0;
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="multi_set">multi_set</h3>
<p>写多条数据（同一hashkey下面）</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief multi_set (guarantee atomicity)
    ///     store multiple k-v of the same hashkey to the cluster.
    /// \param hashkey
    /// used to decide which partition to put this k-v
    /// \param kvs
    /// all &lt;sortkey,value&gt; pairs to be set. should not be empty
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \param ttl_seconds
    /// time to live of this value, if expired, will return not found; 0 means no ttl
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string().
    /// return PERR_INVALID_ARGUMENT if param kvs is empty.
    ///
    virtual int multi_set(const std::string &amp;hashkey,
                          const std::map&lt;std::string, std::string&gt; &amp;kvs,
                          int timeout_milliseconds = 5000,
                          int ttl_seconds = 0,
                          internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="async_multi_set">async_multi_set</h3>
<p>异步写多条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief asynchronous multi_set (guarantee atomicity)
    ///     store multiple k-v of the same hashkey to the cluster.
    ///     will not be blocked, return immediately.
    /// \param hashkey
    /// used to decide which partition to put this k-v
    /// \param kvs
    /// all &lt;sortkey,value&gt; pairs to be set. should not be empty
    /// \param callback
    /// the callback function will be invoked after operation finished or error occurred.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \param ttl_seconds
    /// time to live of this value, if expired, will return not found; 0 means no ttl
    /// \return
    /// void.
    ///
    virtual void async_multi_set(const std::string &amp;hashkey,
                                 const std::map&lt;std::string, std::string&gt; &amp;kvs,
                                 async_multi_set_callback_t &amp;&amp;callback = nullptr,
                                 int timeout_milliseconds = 5000,
                                 int ttl_seconds = 0) = 0;
</code></pre></div></div>

<h3 id="get">get</h3>
<p>读取一条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief get
    ///     get value by key from the cluster.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param value
    /// the returned value will be put into it.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string().
    /// returns PERR_NOT_FOUND if no value is found under the &lt;hashkey,sortkey&gt;.
    ///
    virtual int get(const std::string &amp;hashkey,
                    const std::string &amp;sortkey,
                    std::string &amp;value,
                    int timeout_milliseconds = 5000,
                    internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="async_get">async_get</h3>
<p>异步读取一条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief asynchronous get
    ///     get value by key from the cluster.
    ///     will not be blocked, return immediately.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param callback
    /// the callback function will be invoked after operation finished or error occurred.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// void.
    ///
    virtual void async_get(const std::string &amp;hashkey,
                           const std::string &amp;sortkey,
                           async_get_callback_t &amp;&amp;callback = nullptr,
                           int timeout_milliseconds = 5000) = 0;
</code></pre></div></div>

<h3 id="multi_get">multi_get</h3>
<p>读取多条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief multi_get
    ///     get multiple value by key from the cluster.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkeys
    /// all the k-v under hashkey will be sorted by sortkey.
    /// if empty, means fetch all sortkeys under the hashkey.
    /// \param values
    /// the returned &lt;sortkey,value&gt; pairs will be put into it.
    /// if data is not found for some &lt;hashkey,sortkey&gt;, then it will not appear in the map.
    /// \param max_fetch_count
    /// max count of k-v pairs to be fetched. max_fetch_count &lt;= 0 means no limit.
    /// \param max_fetch_size
    /// max size of k-v pairs to be fetched. max_fetch_size &lt;= 0 means no limit.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string().
    /// returns PERR_OK if fetch done, even no data is returned.
    /// returns PERR_INCOMPLETE is only partial data is fetched.
    ///
    virtual int multi_get(const std::string &amp;hashkey,
                          const std::set&lt;std::string&gt; &amp;sortkeys,
                          std::map&lt;std::string, std::string&gt; &amp;values,
                          int max_fetch_count = 100,
                          int max_fetch_size = 1000000,
                          int timeout_milliseconds = 5000,
                          internal_info *info = NULL) = 0;
</code></pre></div></div>
<p>注：max_fetch_count 和 max_fetch_size 分别从kv-pair的条数 和 总的大小来限制multi_get的返回值</p>

<h3 id="async_multi_get">async_multi_get</h3>
<p>异步读取多条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief asynchronous multi_get
    ///     get multiple value by key from the cluster.
    ///     will not be blocked, return immediately.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkeys
    /// all the k-v under hashkey will be sorted by sortkey.
    /// if empty, means fetch all sortkeys under the hashkey.
    /// \param callback
    /// the callback function will be invoked after operation finished or error occurred.
    /// \param max_fetch_count
    /// max count of k-v pairs to be fetched. max_fetch_count &lt;= 0 means no limit.
    /// \param max_fetch_size
    /// max size of k-v pairs to be fetched. max_fetch_size &lt;= 0 means no limit.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// void.
    ///
    virtual void async_multi_get(const std::string &amp;hashkey,
                                 const std::set&lt;std::string&gt; &amp;sortkeys,
                                 async_multi_get_callback_t &amp;&amp;callback = nullptr,
                                 int max_fetch_count = 100,
                                 int max_fetch_size = 1000000,
                                 int timeout_milliseconds = 5000) = 0;
</code></pre></div></div>

<h3 id="multi_get_sortkeys">multi_get_sortkeys</h3>
<p>获取hashkey下面的多个sortkey，不返回value</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief multi_get_sortkeys
    ///     get multiple sort keys by hash key from the cluster.
    ///     only fetch sort keys, but not fetch values.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkeys
    /// the returned sort keys will be put into it.
    /// \param max_fetch_count
    /// max count of sort keys to be fetched. max_fetch_count &lt;= 0 means no limit.
    /// \param max_fetch_size
    /// max size of sort keys to be fetched. max_fetch_size &lt;= 0 means no limit.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string().
    /// returns PERR_OK if fetch done, even no data is returned.
    /// returns PERR_INCOMPLETE is only partial data is fetched.
    ///
    virtual int multi_get_sortkeys(const std::string &amp;hashkey,
                                   std::set&lt;std::string&gt; &amp;sortkeys,
                                   int max_fetch_count = 100,
                                   int max_fetch_size = 1000000,
                                   int timeout_milliseconds = 5000,
                                   internal_info *info = NULL) = 0;
</code></pre></div></div>
<p>注：max_fetch_count 和 max_fetch_size 分别限制返回的sortkey的个数与总大小（计算大小的时候，为每条sortkey都计算一次hashkey的大小）</p>

<h3 id="async_multi_get_sortkeys">async_multi_get_sortkeys</h3>
<p>异步获取hashkey下面的多个sortkey（不包含value）</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief asynchronous multi_get_sortkeys
    ///     get multiple sort keys by hash key from the cluster.
    ///     only fetch sort keys, but not fetch values.
    ///     will not be blocked, return immediately.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param callback
    /// the callback function will be invoked after operation finished or error occurred.
    /// \param max_fetch_count
    /// max count of sort keys to be fetched. max_fetch_count &lt;= 0 means no limit.
    /// \param max_fetch_size
    /// max size of sort keys to be fetched. max_fetch_size &lt;= 0 means no limit.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// void.
    ///
    virtual void async_multi_get_sortkeys(const std::string &amp;hashkey,
                                          async_multi_get_sortkeys_callback_t &amp;&amp;callback = nullptr,
                                          int max_fetch_count = 100,
                                          int max_fetch_size = 1000000,
                                          int timeout_milliseconds = 5000) = 0;
</code></pre></div></div>

<h3 id="exist">exist</h3>
<p>判断单条数据是否存在</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief exist
    ///     check value exist by key from the cluster.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string().
    /// returns PERR_OK if exist.
    /// returns PERR_NOT_FOUND if not exist.
    ///
    virtual int exist(const std::string &amp;hashkey,
                      const std::string &amp;sortkey,
                      int timeout_milliseconds = 5000,
                      internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="sortkey_count">sortkey_count</h3>
<p>统计hashkey下面的sortkey个数</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief sortkey_count
    ///     get sortkey count by hashkey from the cluster.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param count
    /// the returned sortkey count
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string().
    ///
    virtual int sortkey_count(const std::string &amp;hashkey,
                              int64_t &amp;count,
                              int timeout_milliseconds = 5000,
                              internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="del">del</h3>
<p>删除单条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief del
    ///     del stored k-v by key from cluster
    ///     key is composed of hashkey and sortkey. must provide both to get the value.
    /// \param hashkey
    /// used to decide from which partition to del this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string()
    ///
    virtual int del(const std::string &amp;hashkey,
                    const std::string &amp;sortkey,
                    int timeout_milliseconds = 5000,
                    internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="async_del">async_del</h3>
<p>异步删除单条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief asynchronous del
    ///     del stored k-v by key from cluster
    ///     key is composed of hashkey and sortkey. must provide both to get the value.
    ///     will not be blocked, return immediately.
    /// \param hashkey
    /// used to decide from which partition to del this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param callback
    /// the callback function will be invoked after operation finished or error occurred.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// void.
    ///
    virtual void async_del(const std::string &amp;hashkey,
                           const std::string &amp;sortkey,
                           async_del_callback_t &amp;&amp;callback = nullptr,
                           int timeout_milliseconds = 5000) = 0;
</code></pre></div></div>

<h3 id="multi_del">multi_del</h3>
<p>删除多条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief multi_del
    ///     delete multiple value by key from the cluster.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkeys
    /// all the k-v under hashkey will be sorted by sortkey. should not be empty.
    /// \param deleted_count
    /// return count of deleted k-v pairs.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string().
    ///
    virtual int multi_del(const std::string &amp;hashkey,
                          const std::set&lt;std::string&gt; &amp;sortkeys,
                          int64_t &amp;deleted_count,
                          int timeout_milliseconds = 5000,
                          internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="async_multi_del">async_multi_del</h3>
<p>异步的删除多条数据</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief asynchronous multi_del
    ///     delete multiple value by key from the cluster.
    ///     will not be blocked, return immediately.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkeys
    /// all the k-v under hashkey will be sorted by sortkey. should not be empty.
    /// \param callback
    /// the callback function will be invoked after operation finished or error occurred.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// void.
    ///
    virtual void async_multi_del(const std::string &amp;hashkey,
                                 const std::set&lt;std::string&gt; &amp;sortkeys,
                                 async_multi_del_callback_t &amp;&amp;callback = nullptr,
                                 int timeout_milliseconds = 5000) = 0;
</code></pre></div></div>

<h3 id="ttl">ttl</h3>
<p>获取单行数据的TTL时间。TTL表示Time To Live，表示该数据还能存活多久。如果超过存活时间，数据就读不到了</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief ttl (time to live)
    ///     get ttl in seconds of this k-v.
    ///     key is composed of hashkey and sortkey. must provide both to get the value.
    /// \param hashkey
    /// used to decide which partition to get this k-v
    /// \param sortkey
    /// all the k-v under hashkey will be sorted by sortkey.
    /// \param ttl_seconds
    /// the returned ttl value in seconds.
    /// \param timeout_milliseconds
    /// if wait longer than this value, will return time out error
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string()
    ///
    virtual int ttl(const std::string &amp;hashkey,
                    const std::string &amp;sortkey,
                    int &amp;ttl_seconds,
                    int timeout_milliseconds = 5000,
                    internal_info *info = NULL) = 0;
</code></pre></div></div>

<h3 id="get_scanner">get_scanner</h3>
<p>获取针对某个hashkey下的sortkey区间 [sortkeyA ~ sortkeyB)的一个scanner</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief get hash scanner
    ///     get scanner for [start_sortkey, stop_sortkey) of hashkey
    /// \param hashkey
    /// cannot be empty
    /// \param start_sortkey
    /// sortkey to start with
    /// \param stop_sortkey
    /// sortkey to stop. ""(empty string) represents the max key
    /// \param options
    /// which used to indicate scan options, like which bound is inclusive
    /// \param scanner
    /// out param, used to get k-v
    /// this pointer should be deleted when scan complete
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string()
    ///
    virtual int get_scanner(const std::string &amp;hashkey,
                            const std::string &amp;start_sortkey, // start from beginning if this set ""
                            const std::string &amp;stop_sortkey,  // to the last item if this set ""
                            const scan_options &amp;options,
                            pegasus_scanner *&amp;scanner) = 0;
</code></pre></div></div>

<h3 id="async_get_scanner">async_get_scanner</h3>
<p>异步获取针对某个hashkey下的sortkey区间 [sortkeyA ~ sortkeyB)的一个scanner</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief async get hash scanner
    ///     get scanner for [start_sortkey, stop_sortkey) of hashkey
    ///     will not be blocked, return immediately.
    /// \param hashkey
    /// cannot be empty
    /// \param start_sortkey
    /// sortkey to start with
    /// \param stop_sortkey
    /// sortkey to stop. ""(empty string) represents the max key
    /// \param options
    /// which used to indicate scan options, like which bound is inclusive
    /// \param callback
    /// return status and scanner in callback, and the latter should be deleted when scan complete
    ///
    virtual void
    async_get_scanner(const std::string &amp;hashkey,
                      const std::string &amp;start_sortkey, // start from beginning if this set ""
                      const std::string &amp;stop_sortkey,  // to the last item if this set ""
                      const scan_options &amp;options,
                      async_get_scanner_callback_t &amp;&amp;callback) = 0;
</code></pre></div></div>

<h3 id="get_unordered_scanners">get_unordered_scanners</h3>
<p>获取一个遍历所有数据的scanner</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief get a bundle of scanners to iterate all k-v in table
    ///        scanners should be deleted when scan complete
    /// \param max_split_count
    /// the number of scanners returned will always &lt;= max_split_count
    /// \param options
    /// which used to indicate scan options, like timeout_milliseconds
    /// \param scanners
    /// out param, used to get k-v
    /// these pointers should be deleted
    /// \return
    /// int, the error indicates whether or not the operation is succeeded.
    /// this error can be converted to a string using get_error_string()
    ///
    virtual int get_unordered_scanners(int max_split_count,
                                       const scan_options &amp;options,
                                       std::vector&lt;pegasus_scanner *&gt; &amp;scanners) = 0;
</code></pre></div></div>

<h3 id="async_get_unordered_scanners">async_get_unordered_scanners</h3>
<p>异步获取一个遍历所有数据的scanner</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ///
    /// \brief async get a bundle of scanners to iterate all k-v in table
    ///        scannners return by callback should be deleted when all scan complete
    /// \param max_split_count
    /// the number of scanners returned will always &lt;= max_split_count
    /// \param options
    /// which used to indicate scan options, like timeout_milliseconds
    /// \param callback; return status and scanner in this callback
    ///
    virtual void
    async_get_unordered_scanners(int max_split_count,
                                 const scan_options &amp;options,
                                 async_get_unordered_scanners_callback_t &amp;&amp;callback) = 0;
</code></pre></div></div>

                </div>
            </section>
            <footer class="footer">
    <div class="container">
        <div class="content is-small has-text-centered">
            <div style="margin-bottom: 20px;">
                <a href="http://incubator.apache.org"><img src="/assets/images/egg-logo.png"
                                                           alt="Apache Incubator"/></a>
            </div>
            Copyright &copy; 2020 <a href="http://www.apache.org">The Apache Software Foundation</a>.
            Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version
            2.0</a>.
            <br><br>
            
            Apache Pegasus is an effort undergoing incubation at The Apache Software Foundation (ASF),
            sponsored by the Apache Incubator. Incubation is required of all newly accepted projects
            until a further review indicates that the infrastructure, communications, and decision making process
            have stabilized in a manner consistent with other successful ASF projects. While incubation status is
            not necessarily a reflection of the completeness or stability of the code, it does indicate that the
            project has yet to be fully endorsed by the ASF.
            
        </div>
    </div>
</footer>
        </div>

        <!-- right panel -->
        <div class="dashboard-panel is-small is-scrollable is-hidden-mobile">
            <p class="menu-label">
    <span class="icon">
        <i class="fa fa-bars" aria-hidden="true"></i>
    </span>
    本页导航
</p>
<ul class="menu-list">
  <li><a href="#获取cpp客户端">获取Cpp客户端</a></li>
  <li><a href="#配置文件">配置文件</a></li>
  <li><a href="#接口定义">接口定义</a>
    <ul>
      <li><a href="#创建client实例">创建Client实例</a></li>
      <li><a href="#pegasus_client接口">pegasus_client接口</a>
        <ul>
          <li><a href="#set">set</a></li>
          <li><a href="#async_set">async_set</a></li>
          <li><a href="#multi_set">multi_set</a></li>
          <li><a href="#async_multi_set">async_multi_set</a></li>
          <li><a href="#get">get</a></li>
          <li><a href="#async_get">async_get</a></li>
          <li><a href="#multi_get">multi_get</a></li>
          <li><a href="#async_multi_get">async_multi_get</a></li>
          <li><a href="#multi_get_sortkeys">multi_get_sortkeys</a></li>
          <li><a href="#async_multi_get_sortkeys">async_multi_get_sortkeys</a></li>
          <li><a href="#exist">exist</a></li>
          <li><a href="#sortkey_count">sortkey_count</a></li>
          <li><a href="#del">del</a></li>
          <li><a href="#async_del">async_del</a></li>
          <li><a href="#multi_del">multi_del</a></li>
          <li><a href="#async_multi_del">async_multi_del</a></li>
          <li><a href="#ttl">ttl</a></li>
          <li><a href="#get_scanner">get_scanner</a></li>
          <li><a href="#async_get_scanner">async_get_scanner</a></li>
          <li><a href="#get_unordered_scanners">get_unordered_scanners</a></li>
          <li><a href="#async_get_unordered_scanners">async_get_unordered_scanners</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

        </div>
    </div>

    <script src="/assets/js/app.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>

<script>
    docsearch({
        indexName: 'apache_pegasus',
        apiKey: '676624c2d6dc00808d3b7cf6724fc3c8',
        inputSelector: '.searchbox-input',
        debug: true,
    });
</script>
</body>

</html>